\documentclass[11pt,a4paper]{book}

\usepackage{Appunti}
\usepackage[utf8]{inputenc}
\usepackage[hyperfootnotes=false, colorlinks=true, linkcolor=black]{hyperref}
\usepackage[style=numeric-comp,useprefix,hyperref,backend=bibtex]{biblatex}
\usepackage{listings}  % Serve per evidenziare i blocchi di codice
\usepackage{pxfonts} % permette di avere caratteri in lstlisting con formattazione

\setlength{\parskip}{1em} % cambia l'interlinea prima di un nuovo capoverso

% Colori per lstlisting
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}
\definecolor{maroon}{rgb}{0.5,0,0}
\definecolor{plightgrey}{rgb}{0.8,0.8,0.8} 


\usepackage{xcolor} % Necessario per definire i colori
\hypersetup{
  colorlinks=true,
  linkcolor=green!70!black,
  urlcolor=green!70!black
} % Setup colore link


\lstset{ % Riduce la larghezza della tabulazione per lstlisting
  tabsize=2,
  backgroundcolor=\color{plightgrey},
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  columns=fullflexible,
  frame=single,
}


\lstset{
  language=XML,
  basicstyle=\ttfamily,
  morestring=[s]{"}{"},
  morecomment=[s]{?}{?},
  morecomment=[s]{!--}{--},
  commentstyle=\color{white},
  moredelim=[s][\color{black}]{>}{<},
  moredelim=[s][\color{red}]{\ }{=},
  stringstyle=\color{blue},
  identifierstyle=\color{maroon}
}
% Crea un set di impostazioni per Java in lstlisting
\lstset{language=Java,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{white},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\ttfamily,
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}

\begin{document}
\title{Concurrency, Multithreading and Parallel Computing in Java}
\author{Jacopo De Angelis}
\maketitle

\pagebreak
\tableofcontents
\pagebreak

\chapter{Multhithreading theory}
\section{Processi e thread}
I processi e i thread sono indipendenti tra di loro:
\begin{itemize}
	\item i \textbf{processi} sono l'istanza di esecuzione: ogni processo ha registri indipendenti, uno stack di memoria e un heap per ogni procesos. In java si crea con \textbf{ProcessBuilder}.
	\item i \textbf{thread} sono l'unità di esecuzione di un processo: un processo può avere più thread, ogni thread condivide memoria e risorse.
\end{itemize}

\section{Time slicing}
Il tempo di funzionamento di un core è diviso tra i suoi thread, il modo nel quale il tempo è diviso tra di essi è deciso tramite un algoritmo di time slicing.

\section{Vantaggi del multithreading}
La possibilità di svolgere più lavori contemporaneamente senza dovere attendere la fine di uno per iniziare l'altro.

\section{Svantaggi del multithreading}
Problemi di sincronizzazione e di utilizzo delle risorse possono rendere il multithreading inefficiente. Il debug è più complicato.

\section{Ciclo di vita di un thread}
\begin{itemize}
	\item instanziazione (new): quando viene creato
	\item in funzione (runnable): quando viene eseguito tramite start()
	\item in attesa (waiting): passaggio ad uno stato di attesa tramite wait() e sleep()
	\item fine vita (dead): quando il thread termina la sua funzione
\end{itemize}

\chapter{Manipolazione dei thread}
\section{Interfaccia Runnable}
\href{https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html}{Runnable} porta ad implementare una funzione run() dentro alla quale viene posta la parte logica del thread. Il thread a questo punto viene eseguito tramite start()

\section{Classe Thread}
Estendendo la classe \href{https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html}{Thread} si ottiene lo stesos risultato ma con il limite di non potere estendere altre classi, si ottengono però i suoi metodi.

\section{join()}
\emph{thread.join()} attende la fine dell'esecuzione del thread. Serve per segnalare quando il thread muore.

\section{Deamon e Worker}
\begin{itemize}
	\item \textbf{Deamon}: è un thread che vive durante tutta la vita del \textbf{processo}. Sono thread di aiuto, ad esempio il garbage collector. 
	\item \textbf{Worker}: è un thread che vive durante la propria vita
\end{itemize}

\chapter{Comunicazione tra thread}
Le variabili locali vivono sullo stack, gli oggetti che sono instanziati vivono sull'heap. \textbf{Ogni thread ha il suo stack ma tutti i thread condividono l'heap.} 

\section{Sincronizzazione}
Se due thread devono agire sullo stesso campo si crea un problema di accesso e scrittura su di esso. Per questo si usa l'accessore \emph{synchronized} sul metodo, in questo modo solo un thread alla volta può chiamarlo.

Il problema è che definire così un metodo porta il thread ad acquisire il lock sulla classe, non sul metodo, quindi anche se ci fossero due metodi indipendenti synchronized, comunque non potrebbero essere eseguiti contemporaneamente. è meglio non mettere come synchronized il metodo ma un blocco all'interno del codice, ad esempio
\begin{lstlisting}[language = Java]
public static void increment1() {
	synchronized(App.class) {
		counter++
	}
}
\end{lstlisting}
Questo comunque non risolve il problema del lock sulla classe, per quello possiamo usare un oggetto come lock:
\begin{lstlisting}[language = Java]
public class App {
	public static int counter1 = 0;
	public static int counter2 = 0;
	
	private static final Object lock1 = new Object();
	private static final Object lock2 = new Object();
	
	public static void increment1() {
		synchronized(lock1) {
			counter1++
		}
	}
	
	public static void increment2() {
		synchronized(lock2) {
			counter2++
		}
	}
\end{lstlisting}
In questo modo si ha un lock a livello di oggetto.
\section{wait() e notify()}
Due thread con lo stesso lock possono comunicare tra di loro con due metodi:
\begin{itemize}
	\item wait(): il thread entra in stato di attesa fino a quando il token non viene rilasciato
	\item notify(): rilascia il lock e avvisa la thread pool che può essere preso
\end{itemize}

\section{Reentrant lock}
Un thread non può acquisire un lock più volte a meno che questo non sia un ReentrantLock

\chapter{Concetti di multithreading}
\section{Volatile}
volatile è un accesso che segnala di NON inserire all'interno della cache una variabile. Per quanto la cache sia più veloce, bisogna scegliere accuratamente cosa inserirci in quanto non si possono svolgere azioni di riorganizzazione automatica della memoria sulla cache, uno strumento di potenziamento delle performance.
\section{Fermare un thread}
Se si vuole interrompere un thread in maniera sicura non bisogna usare stop() ma interrupt().
\section{Deadlock e Livelock}
\begin{itemize}
	\item \textbf{Deadlock}: quando due thread attendono che l'altro finisca e quindi nessuno prende il comando
	\item \textbf{Livelock}: due thread sono troppo impegnati a passare il controllo all'altro per eseguire le proprie funzioni.
\end{itemize}

Per gestirli è meglio usare tryLock() come metodo.
\section{Variabili atomiche}
Sono variabili che consentono di rendere l'accesso ad essere non interrompibile, in questo modo la sincronizzazione è fatta a livello di variabile.
\section{\href{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html}{Semafori}}
I semafori sono dei tipi astratti che sono usati per regolare l'accesso a risorse condivise. Possono essere:
\begin{itemize}
	\item a conteggio: contiene un conteggio di risorse arbitrario
	\item binario: è acceso o spento
\end{itemize}

\section{Mutex}
Sono semafori binari, quindi un solo thread può accedere al blocco controllato dalla mutex.

\chapter{Creazione di threads con l'Executor Framework}
L'utilizzo delle thread pool e l'Executor Framework aiuta a rendere gestibile il multithreading. Il vantaggio delle thread pool è il riutilizzo dei thread, questo perchè la loro creazione è costosa.
Ci sono 4 tipi di Executor:
\begin{itemize}
	\item \textbf{SingleThreadExecutor}: ha un solo thread
	\item \textbf{FixedThreadPool(n)}: permette di decidere un numero n di thread, solitamente il numero di core della CPU
	\item \textbf{CachedThreadPool}: il numero di thread non è limitato, se sono tutti occupai e arriva un nuovo task la pool creerà un nuovo thread, se rimane in idle 60 secondi viene rimosso, è usato solitamente per compiti paralleli brevi
	\item \textbf{ScheduledExecutor}: Possiamo eseguire una data operazione e intervalli regolari o possiamo usarlo per definire un ritardo nell'esecuzione di certi task
\end{itemize}

\section{Interfacce Runnable e Callable}
\begin{itemize}
	\item \textbf{Runnable}: run-and-forget. Dopo essere stata eseguita non ritorna un valore. Si chiama con executorService.execute()
	\item \textbf{Callable$<$T$>$}: ritorna un valore di tipo \textbf{Futuree$<$T$>$}. Si chiama con executorService.submit()
\end{itemize}

\chapter{Concurrent Collections}
Possiamo rendere una collezione sincronizzata tramite \emph{Collections.syncronizedList($<$lista$>$), Collections.syncronizedMap($<$map$>$), Collections.syncronizedSet($<$set$>$)}.
\section{\href{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html}{CountDownLatch}}
Il countdown del Latch è legato al numero di esecuzioni di run vengono completate.
\section{\href{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html}{CyclicBarrier}}
Permette di costringere un set di thread di attendere fino a quando tutti sono arrivati alla barriera tramite await().
\section{\href{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html}{BlockingQueue}}
Ha come sempre una struttura FIFO ma in più è sincronizzata.
\section{\href{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html}{DelayQueue}}
è una BlockingQueue con l'interfaccia aggiuntiva Delay, quindi si può prendere un oggetto dalla coda solo se il delay è terminato.
\section{\href{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html}{PriorityBlockingQueue}}
è un'implementazione della BlockingQueue e una versione thread safe della PriorityQueue. 
\section{\href{https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html}{ConcurrentMap}}
Non è molto efficiente perchè così la mappa ottiene un lock intrinseco anche per azioni non concorrenziali. Possiamo, però, rendere una mappa sincronizzata a segmenti, dividendola così in n segmenti da m elementi, ognuno con un suo lock.
\section{\href{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html}{Exchanger}}
è un punto di scambio tra thread per scambiarsi elementi.


\end{document}