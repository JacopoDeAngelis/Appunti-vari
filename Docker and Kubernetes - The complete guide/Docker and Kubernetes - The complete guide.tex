\documentclass[11pt,a4paper]{book}

\usepackage{Appunti}

\definecolor{groovyblue}{HTML}{0000A0}
\definecolor{groovygreen}{HTML}{008000}
\definecolor{darkgray}{rgb}{.4,.4,.4}
 
\lstdefinelanguage{Groovy}[]{Java}{
  keywordstyle=\color{groovyblue}\bfseries,
  stringstyle=\color{groovygreen}\ttfamily,
  keywords=[3]{each, findAll, groupBy, collect, inject, eachWithIndex},
  morekeywords={def, as, in, use},
  moredelim=[is][\textcolor{darkgray}]{\%\%}{\%\%},
  moredelim=[il][\textcolor{darkgray}]{§§}
}

\begin{document}
\title{Docker and Kubernetes: The Complete Guide}
\author{Jacopo De Angelis}
\maketitle

\pagebreak
\tableofcontents
\pagebreak

\chapter{Perchè usare docker e cos'è?}
Docker si prefigge di permettere di passare un software senza doversi preoccupare di dipendenze o altro.

Immagine: un singolo file con tutte le dipendenze e le configurazioni richieste per lanciare un programma.

Container: istanza di un'immagine. 

Il docker client ci permette di interfacciarci con il docker server, un programma col quale non ci interfacciamo direttamente ma è un processo che lavora dietro le quinte.

\chapter{Manipolazione dei container}
\emph{docker run <nome immagine>}: lancia il programma all'interno del programma.

\emph{docker run <nome immagine> <comando>}: all'interno di un'immagine viene lanciato il comando specificato e non quello di default. Nel caso il comando non fosse presente all'interno delle cartelle verrà mostrato un messaggio d'errore.

Quando viene lanciato run viene creato un container. Tutti i container possono essere mostrati tramite \emph{docker ps --all}.



\end{document}